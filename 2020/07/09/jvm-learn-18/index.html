<!DOCTYPE html>
<html lang="en">
<head>
<title>JVM Learn 18 JVM垃圾回收模型概述 :: DongZhi.ME — A simple, retro blog for latest information technology!</title>
<meta content="text/html; charset=utf-8" http-equiv="content-type"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta content="Java虚拟机的垃圾回收主要从三个方面去概括： 垃圾判断算法 GC(垃圾回收)算法 垃圾回收器的实现和选择 垃圾判断算法 垃圾判断算法，用于确定什么是垃圾内存。主要包括引用计数算法和根搜索算法。 引用计数算法 引用" name="description"/>
<meta content="" name="keywords"/>
<meta content="noodp" name="robots"/>
<link href="https://dongzhi.me/2020/07/09/jvm-learn-18/" rel="canonical"/>
<link href="https://dongzhi.me/assets/style.css" rel="stylesheet"/>
<link href="https://cdn.jsdelivr.net/gh/bugfix123/CDN@master/dongzhi.me/favicon_io//apple-touch-icon.png" rel="apple-touch-icon" sizes="180x180"/>
<link href="https://cdn.jsdelivr.net/gh/bugfix123/CDN@master/dongzhi.me/favicon_io//favicon-32x32.png" rel="icon" sizes="32x32" type="image/png"/>
<link href="https://cdn.jsdelivr.net/gh/bugfix123/CDN@master/dongzhi.me/favicon_io//favicon-16x16.png" rel="icon" sizes="16x16" type="image/png"/>
<link href="https://cdn.jsdelivr.net/gh/bugfix123/CDN@master/dongzhi.me/favicon_io//site.webmanifest" rel="manifest"/>
<meta content="summary" name="twitter:card"/>
<meta content="Joe John" name="twitter:creator"/>
<meta content="en" property="og:locale"/>
<meta content="article" property="og:type"/>
<meta content="JVM Learn 18 JVM垃圾回收模型概述 :: DongZhi.ME" property="og:title"/>
<meta content="Java虚拟机的垃圾回收主要从三个方面去概括： 垃圾判断算法 GC(垃圾回收)算法 垃圾回收器的实现和选择 垃圾判断算法 垃圾判断算法，用于确定什么是垃圾内存。主要包括引用计数算法和根搜索算法。 引用计数算法 引用" property="og:description"/>
<meta content="https://dongzhi.me/2020/07/09/jvm-learn-18/" property="og:url"/>
<meta content="JVM Learn 18 JVM垃圾回收模型概述" property="og:site_name"/>
<meta content="https://dongzhi.me/" property="og:image"/>
<meta content="2048" property="og:image:width"/>
<meta content="1024" property="og:image:height"/>
<meta content="2020-07-09 00:00:00 +0000 UTC" property="article:published_time"/>
<link href="https://cdn.jsdelivr.net/gh/bugfix123/CDN@master/modules/plyr/3.6.2/plyr.css" rel="stylesheet"/>
<link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet"/>
</head>
<body class="">
<div class="container center headings--one-size">
<header class="header">
<div class="header__inner">
<div class="header__logo">
<a href="/">
<div class="logo">
    DongZhi.ME
  </div>
</a>
</div>
<div class="menu-trigger">menu</div>
</div>
<nav class="menu">
<ul class="menu__inner menu__inner--desktop">
<li><a href="/">Home</a></li>
<li><a href="/archives">Archives</a></li>
<li><a href="/tags">Tags</a></li>
<li><a href="/search">Search</a></li>
<li><a href="/about">About</a></li>
</ul>
<ul class="menu__inner menu__inner--mobile">
<li><a href="/">Home</a></li>
<li><a href="/archives">Archives</a></li>
<li><a href="/tags">Tags</a></li>
<li><a href="/search">Search</a></li>
<li><a href="/about">About</a></li>
</ul>
</nav>
</header>
<div class="content">
<div class="post">
<h1 class="post-title">
<a href="https://dongzhi.me/2020/07/09/jvm-learn-18/">JVM Learn 18 JVM垃圾回收模型概述</a></h1>
<div class="post-meta">
<span class="post-date">
        2020-07-09 
      </span>
<span class="post-author">::
      Joe John
    </span>
</div>
<div class="post-content"><div>
<p>Java虚拟机的垃圾回收主要从三个方面去概括：</p>
<ul>
<li>垃圾判断算法</li>
<li>GC(垃圾回收)算法</li>
<li>垃圾回收器的实现和选择</li>
</ul>
<h1 id="垃圾判断算法">垃圾判断算法<a arialabel="Anchor" class="hanchor" href="#垃圾判断算法">⌗</a> </h1>
<p>垃圾判断算法，用于确定什么是垃圾内存。主要包括引用计数算法和根搜索算法。</p>
<ul>
<li><strong>引用计数算法</strong></li>
</ul>
<p>引用计数算法，给对象添加一个引用计数器，当有一个地方引用它，计数器加1，当引用失效了，计数器减1，当计数器的值为0，表示这个对象不再被使用，内存可以回收。有点：算法简单，缺点是无法解决循环引用问题。</p>
<ul>
<li><strong>根搜索算法</strong></li>
</ul>
<p>通过一系列称为GC Roots的点作为搜素的起始点，如果一个对象到GC Roots节点没有任何引用链，则表示这个对象不可用了。</p>
<p>GC Roots包括：</p>
<ul>
<li>栈帧中的局部变量表中引用</li>
<li>方法区中的静态引用</li>
<li>JNI中的引用</li>
</ul>
<h1 id="方法区的垃圾回收">方法区的垃圾回收<a arialabel="Anchor" class="hanchor" href="#方法区的垃圾回收">⌗</a> </h1>
<p>JVM规范并不要求回收方法区中的垃圾内存，因为性价比极低。在堆中，尤其在新生代，一次GC通常可以回收70%~95%的空间，GC在方法区中回收的比例远低于此。</p>
<p>当前商业JVM都实现了方法区的GC，主要回收<strong>废弃常量和无用类</strong>，要求非常苛刻。</p>
<h1 id="垃圾回收算法">垃圾回收算法<a arialabel="Anchor" class="hanchor" href="#垃圾回收算法">⌗</a> </h1>
<ol>
<li>标记-清除算法(Mark-Sweep)</li>
</ol>
<p>算法分为<strong>标记</strong>和<strong>清除</strong>两个阶段，首先标记出所有需要回收的对象，然后回收所有标记的对象。存在的问题：
1. <strong>效率问题</strong>：标记和清除的效率都不高。需要扫描所有对象，堆越大，GC越慢
2. <strong>空间问题</strong>：标记清除之后会产生大量不连续的内存碎片，内存碎片太多会导致后续无法找到足够的连续内存而提前触发一次GC。GC次数越多，内存碎片越严重。</p>
<p><strong>原始</strong>
<img alt="0011" src="/post/images/2020/jvm_18_0011.png"/></p>
<p><strong>标记</strong>
<img alt="0012" src="/post/images/2020/jvm_18_0012.png"/></p>
<p><strong>清除</strong>
<img alt="0013" src="/post/images/2020/jvm_18_0013.png"/></p>
<ol>
<li>标记-整理算法(Mark-Compact)</li>
</ol>
<p>标记过程和上面一样，清除时令存活对象的一段移动，然后清除指针边界一侧的内存区域。</p>
<p>这种算法的特点：</p>
<ul>
<li>没有内存碎片</li>
<li>比标记清除算法花更多时间进行compact</li>
</ul>
<ol start="3">
<li><strong>复制算法(Copying)</strong></li>
</ol>
<p>将可用内存分成两块，每次只使用其中的一块，当半区内存用完了，就把当前存活的对象复制到另外一块中去，然后将原来的那一块内存整体一次性清除掉。这样每次回收内存都是对整个半区回收，不用考虑内存碎片问题，分配内存时候只需要移动堆的指针，按顺序分配即可，实现简单，运行高效。<strong>缺点是内存变为原来的一半，空间代价太高。</strong></p>
<p>现代商业虚拟机都是采用复制算法来回收新生代，将新生代划分为eden和2个survivor区，真正只使用eden和其中一块survivor区，另一块survivor区保持空闲，GC时，会将eden和survivor中存货的对象一次性拷贝到空闲的那个survivor中，然后一次性清除eden和原来的survivor区。</p>
<p>复制算法特点：</p>
<ul>
<li>只需要扫描存活的对象，效率更高</li>
<li>不会产生内存扫描</li>
<li>需要浪费额外的内存空间作为复制区域</li>
<li>复制算法适合生命周期非常短的对象，这样每次能回收大部分对象，存活的对象少，相应的复制空间开销就少</li>
</ul>
<ol start="4">
<li><strong>分代算法(Generational)</strong></li>
</ol>
<p>商业虚拟机都是采用分代收集算法，根据对象的存活周期将对象划分为新生代和老年代，各个年代根据自己的特点采用合适的收集算法。比如，新生代大量的对象生命周期很短，存活对象少，只需要付出少量对象的复制空间成本即可。对于老年代可以采用标记清除或标记整理算法回收。
<img alt="gc01" src="/post/images/2020/jvm_18_gc01.png"/>
年轻代包括Eden Space，From Space和To Space这三部分，From Space和To Space又叫Survivor，默认情况下他们的大小比例是8：1：1。
<img alt="gc02" src="/post/images/2020/jvm_18_gc02.png"/></p>
<p>对象一般在Eden Space中生成，当Eden Space满了时，存活的对象被复制到From Space，当Eden Space再次满了，Eden Space中存活的对象和From Space对象中存活的对象一并被复制到To Space，如果To Space对象满了，多余的对象或者存活超龄的对象，就会被复制到老年代。From Space和To Space完全对称，轮流替换。</p>
<p>大多数对象在Eden Space上分配内存，对于一些大对象，直接在老年代分配内存。</p>
<h1 id="gc时的引用处理">GC时的引用处理<a arialabel="Anchor" class="hanchor" href="#gc时的引用处理">⌗</a> </h1>
<p>GC要做的事情是将那些dead对象所占的内存回收。Hotspot认为没有引用的对象是dead的。Hotspot的引用分为4种：</p>
<ul>
<li>Strong 通过Object o = new Object()创建的引用</li>
<li>Soft、Weak和Phantom都是继承自Reference
当Full GC时候，对Reference引用特殊处理：</li>
<li>Soft：内存不够或长期不用时会被GC</li>
<li>Weak：一定被GC</li>
<li>Phantom：本来就没引用，当从JVM 堆中释放内存时会通知</li>
</ul>
<h1 id="gc的时机">GC的时机<a arialabel="Anchor" class="hanchor" href="#gc的时机">⌗</a> </h1>
<p>在分代收集的基础上，GC分为Minor GC和Full GC。</p>
<ul>
<li><strong>Minor GC</strong></li>
</ul>
<p>触发条件：新对象生成时，Eden 满了
特点：大多数对象在Minor GC时回收，效率高，执行的时间比较短</p>
<ul>
<li><strong>Full GC</strong></li>
</ul>
<p>对整个JVM进行整理，包括Young，Old和Metaspace。</p>
<p>触发时机：a. Old满了  b. Metaspace满了  c. 调用System.gc()</p>
<p>效率低，尽量少执行。一旦出现Full GC，就会出现<strong>Stop The World</strong>，业务线程暂停执行。</p>
<h1 id="垃圾回收器">垃圾回收器<a arialabel="Anchor" class="hanchor" href="#垃圾回收器">⌗</a> </h1>
<p>分代模型是GC的宏观愿景，而垃圾回收器是GC算法的具体实现。Hotspot提供了多种垃圾回收器，应当根据具体的业务场景采用不同的垃圾回收器，没有一种垃圾回收器是万能的。</p>
<p>GC时并行和并发的概念：</p>
<ul>
<li>并行(Parallel)：多个GC线程同时工作，而用户线程处于等待状态。</li>
<li>并发(Concurrent)：垃圾回收的同时，运行用户线程工作。</li>
</ul>
<p><strong>单线程收集器(Serial)</strong>：收集时会暂停所有的工作线程，使用复制算法它是JVM在Client模式下的默认新生代垃圾回收器。主要特点：</p>
<ul>
<li>最早的收集器，单线程</li>
<li>新生代和老年代都可以使用</li>
<li>复制算法 + 标记整理算法</li>
</ul>
<p><strong>ParNew收集器</strong>：Serial收集器的多线程版本，算法、STW等都和Serial一样，它是JVM在Server模式下默认的新生代垃圾回收器。</p>
<p><strong>Parallel Scavenge收集器</strong>：多线程收集器，复制算法，它主要特点是吞吐量高，也就是GC的总运行时间短。STW不理想。</p>
<p><strong>Serial Old</strong>：单线程版本收集器，老年代版本。</p>
<p><strong>Parallel Old</strong>：Parallel Scavenge的老年代实现，多线程的标记清除算法，吞吐量好。Parallel Scavenge + Parallel Old=高吞吐量，但是STW不理想。</p>
<p><strong>CMS(Concurrent Mark Sweep)</strong>：很复杂的老年代收集器，主要特点：追求最短停顿时间，并发（GC和用户线程同时进行），标记清除算法，一般结合ParNew收集器。它通过占用很多CPU资源来减少用户线程停顿。</p>
</div></div>
<div class="pagination">
<div class="pagination__title">
<span class="pagination__title-h">Read other posts</span>
<hr/>
</div>
<div class="pagination__buttons">
<span class="button previous">
<a href="https://dongzhi.me/2020/07/09/jvm-learn-17/">
<span class="button__icon">←</span>
<span class="button__text">JVM Learn 17 JVM内存排查相关命令用法</span>
</a>
</span>
<span class="button next">
<a href="https://dongzhi.me/2020/07/09/jvm-learn-19/">
<span class="button__text">JVM Learn 19 JVM垃圾回收算法总结</span>
<span class="button__icon">→</span>
</a>
</span>
</div>
</div>
<h3 style="margin-inline-start: 1em;margin-bottom: auto;">评论</h3>
<aside id="comments" style="background: rgb(183 168 154 / 26%);padding: 5px auto;margin: 10px auto;border: 1px dashed var(--accent);">
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.Pure.min.js"></script>
<div id="vcomments"></div>
<script>
      new Valine({
        el: '#comments' ,
        appId: 'sJKN6mA2eSTxIq3YaOiCN3JX-MdYXbMMI',
        appKey: 'aykSxGrm7HLN5BroU1gr3Ot3',
        placeholder: 'go go it~',
        visitor:  false ,
        requiredFields: ['mail'],
        emojiCDN: '//i0.hdslb.com/bfs/emote/',
        emojiMaps: {
          "tv_doge": "6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png",
          "tv_亲亲": "a8111ad55953ef5e3be3327ef94eb4a39d535d06.png",
          "tv_偷笑": "bb690d4107620f1c15cff29509db529a73aee261.png",
          "tv_再见": "180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png",
          "tv_冷漠": "b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png",
          "tv_发怒": "34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png",
          "tv_发财": "34db290afd2963723c6eb3c4560667db7253a21a.png",
          "tv_可爱": "9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png",
          "tv_吐血": "09dd16a7aa59b77baa1155d47484409624470c77.png",
          "tv_呆": "fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png",
          "tv_呕吐": "9f996894a39e282ccf5e66856af49483f81870f3.png",
          "tv_困": "241ee304e44c0af029adceb294399391e4737ef2.png",
          "tv_坏笑": "1f0b87f731a671079842116e0991c91c2c88645a.png",
          "tv_大佬": "093c1e2c490161aca397afc45573c877cdead616.png",
          "tv_大哭": "23269aeb35f99daee28dda129676f6e9ea87934f.png",
          "tv_委屈": "d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png",
          "tv_害羞": "a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png",
          "tv_尴尬": "7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png",
          "tv_微笑": "70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png",
          "tv_思考": "90cf159733e558137ed20aa04d09964436f618a1.png",
          "tv_惊吓": "0d15c7e2ee58e935adc6a7193ee042388adc22af.png",
          "tv_打脸": "56ab10b624063e966bfcb76ea5dc4794d87dfd47.png",
          "tv_抓狂": "fe31c08edad661d63762b04e17b8d5ae3c71a757.png",
          "tv_抠鼻": "c666f55e88d471e51bbd9fab9bb308110824a6eb.png",
          "tv_斜眼笑": "911f987aa8bc1bee12d52aafe62bc41ef4474e6c.png",
          "tv_无奈": "ea8ed89ee9878f2fece2dda0ea8a5dbfe21b5751.png",
          "tv_晕": "5443c22b4d07fb1907ccc610c8e6db254f2461b7.png",
          "tv_流汗": "cead1c351ab8d79e9f369605beb90148db0fbed3.png",
          "tv_流泪": "7e71cde7858f0cd50d74b0264aa26db612a8a167.png",
          "tv_流鼻血": "c32d39db2737f89b904ca32700d140a9241b0767.png",
          "tv_点赞": "f85c354995bd99e28fc76c869bfe42ba6438eff4.png",
          "tv_生气": "26702dcafdab5e8225b43ffd23c94ac1ff932654.png",
          "tv_生病": "8b0ec90e6b86771092a498c54f09fc94621c1900.png",
          "tv_疑问": "0793d949b18d7be716078349c202c15ff166f314.png",
          "tv_白眼": "c1d59f439e379ee50eef488bcb5e5378e5044ea4.png",
          "tv_皱眉": "72ccad6679fea0d14cce648b4d818e09b8ffea2d.png",
          "tv_目瞪口呆": "0b8cb81a68de5d5365212c99375e7ace3e7891b7.png",
          "tv_睡着": "8b196675b53af58264f383c50ad0945048290b33.png",
          "tv_笑哭": "1abc628f6d4f4caf9d0e7800878f4697abbc8273.png",
          "tv_腼腆": "89712c0d4af73e67f89e35cbc518420380a7f6f4.png",
          "tv_色": "61822c7e9aae5da76475e7892534545336b23a6f.png",
          "tv_调侃": "4bc022533ef31544ca0d72c12c808cf4a1cce3e3.png",
          "tv_调皮": "b9c41de8e82dd7a8515ae5e3cb63e898bf245186.png",
          "tv_鄙视": "6e72339f346a692a495b123174b49e4e8e781303.png",
          "tv_闭嘴": "c9e990da7f6e93975e25fd8b70e2e290aa4086ef.png",
          "tv_难过": "87f46748d3f142ebc6586ff58860d0e2fc8263ba.png",
          "tv_馋": "fc7e829b845c43c623c8b490ee3602b7f0e76a31.png",
          "tv_鬼脸": "0ffbbddf8a94d124ca2f54b360bbc04feb6bbfea.png",
          "tv_黑人问号": "45821a01f51bc867da9edbaa2e070410819a95b2.png",
          "tv_鼓掌": "1d21793f96ef4e6f48b23e53e3b9e42da833a0f6.png"
        } 
      });
      
      
      
      
      
      
      
  </script>
</aside>
</div>
</div>
<footer class="footer">
<div class="footer__inner">
<div class="copyright">
<span>© 2020 Powered by <a href="http://gohugo.io">Hugo</a></span>
<span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
</div>
</div>
</footer>
<script src="https://dongzhi.me/assets/main.js"></script>
<script src="https://cdn.jsdelivr.net/gh/bugfix123/CDN@master/modules/plyr/3.6.2/plyr.polyfilled.min.js"></script>
<script>
    const players = Plyr.setup('.js-player', {
        iconUrl: '/modules/plyr/3.6.2/plyr.svg'
    });
    </script>
</div>
</body>
</html>
