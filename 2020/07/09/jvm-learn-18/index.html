<!doctype html><html lang=en><head><title>JVM Learn 18 JVM垃圾回收模型概述 :: DongZhi.ME — A simple, retro blog for latest information technology!</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Java虚拟机的垃圾回收主要从三个方面去概括： 垃圾判断算法 GC(垃圾回收)算法 垃圾回收器的实现和选择 垃圾判断算法 垃圾判断算法，用于确定什么是垃圾内存。主要包括引用计数算法和根搜索算法。 引用计数算法 引用"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://dongzhi.me/2020/07/09/jvm-learn-18/><link rel=stylesheet href=https://dongzhi.me/assets/style.css><link rel=apple-touch-icon sizes=180x180 href=https://cdn.jsdelivr.net/gh/bugfix123/CDN@master/dongzhi.me/favicon_io//apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://cdn.jsdelivr.net/gh/bugfix123/CDN@master/dongzhi.me/favicon_io//favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://cdn.jsdelivr.net/gh/bugfix123/CDN@master/dongzhi.me/favicon_io//favicon-16x16.png><link rel=manifest href=https://cdn.jsdelivr.net/gh/bugfix123/CDN@master/dongzhi.me/favicon_io//site.webmanifest><meta name=twitter:card content="summary"><meta name=twitter:creator content="Joe John"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="JVM Learn 18 JVM垃圾回收模型概述 :: DongZhi.ME"><meta property="og:description" content="Java虚拟机的垃圾回收主要从三个方面去概括： 垃圾判断算法 GC(垃圾回收)算法 垃圾回收器的实现和选择 垃圾判断算法 垃圾判断算法，用于确定什么是垃圾内存。主要包括引用计数算法和根搜索算法。 引用计数算法 引用"><meta property="og:url" content="https://dongzhi.me/2020/07/09/jvm-learn-18/"><meta property="og:site_name" content="JVM Learn 18 JVM垃圾回收模型概述"><meta property="og:image" content="https://dongzhi.me/"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2020-07-09 00:00:00 +0000 UTC"><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/bugfix123/CDN@master/modules/plyr/3.6.2/plyr.css><link href=https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css rel=stylesheet></head><body><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>DongZhi.ME</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/>Home</a></li><li><a href=/archives>Archives</a></li><li><a href=/tags>Tags</a></li><li><a href=/search>Search</a></li><li><a href=/about>About</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/>Home</a></li><li><a href=/archives>Archives</a></li><li><a href=/tags>Tags</a></li><li><a href=/search>Search</a></li><li><a href=/about>About</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://dongzhi.me/2020/07/09/jvm-learn-18/>JVM Learn 18 JVM垃圾回收模型概述</a></h1><div class=post-meta><span class=post-date>2020-07-09</span>
<span class=post-author>::
Joe John</span></div><div class=post-content><div><p>Java虚拟机的垃圾回收主要从三个方面去概括：</p><ul><li>垃圾判断算法</li><li>GC(垃圾回收)算法</li><li>垃圾回收器的实现和选择</li></ul><h1 id=垃圾判断算法>垃圾判断算法<a href=#垃圾判断算法 class=hanchor arialabel=Anchor>&#8983;</a></h1><p>垃圾判断算法，用于确定什么是垃圾内存。主要包括引用计数算法和根搜索算法。</p><ul><li><strong>引用计数算法</strong></li></ul><p>引用计数算法，给对象添加一个引用计数器，当有一个地方引用它，计数器加1，当引用失效了，计数器减1，当计数器的值为0，表示这个对象不再被使用，内存可以回收。有点：算法简单，缺点是无法解决循环引用问题。</p><ul><li><strong>根搜索算法</strong></li></ul><p>通过一系列称为GC Roots的点作为搜素的起始点，如果一个对象到GC Roots节点没有任何引用链，则表示这个对象不可用了。</p><p>GC Roots包括：</p><ul><li>栈帧中的局部变量表中引用</li><li>方法区中的静态引用</li><li>JNI中的引用</li></ul><h1 id=方法区的垃圾回收>方法区的垃圾回收<a href=#方法区的垃圾回收 class=hanchor arialabel=Anchor>&#8983;</a></h1><p>JVM规范并不要求回收方法区中的垃圾内存，因为性价比极低。在堆中，尤其在新生代，一次GC通常可以回收70%~95%的空间，GC在方法区中回收的比例远低于此。</p><p>当前商业JVM都实现了方法区的GC，主要回收<strong>废弃常量和无用类</strong>，要求非常苛刻。</p><h1 id=垃圾回收算法>垃圾回收算法<a href=#垃圾回收算法 class=hanchor arialabel=Anchor>&#8983;</a></h1><ol><li>标记-清除算法(Mark-Sweep)</li></ol><p>算法分为<strong>标记</strong>和<strong>清除</strong>两个阶段，首先标记出所有需要回收的对象，然后回收所有标记的对象。存在的问题：
1. <strong>效率问题</strong>：标记和清除的效率都不高。需要扫描所有对象，堆越大，GC越慢
2. <strong>空间问题</strong>：标记清除之后会产生大量不连续的内存碎片，内存碎片太多会导致后续无法找到足够的连续内存而提前触发一次GC。GC次数越多，内存碎片越严重。</p><p><strong>原始</strong>
<img src=https://cdn.jsdelivr.net/gh/bugfix123/CDN/9527/post/images/2020/jvm_18_0011.png alt=0011></p><p><strong>标记</strong>
<img src=https://cdn.jsdelivr.net/gh/bugfix123/CDN/9527/post/images/2020/jvm_18_0012.png alt=0012></p><p><strong>清除</strong>
<img src=https://cdn.jsdelivr.net/gh/bugfix123/CDN/9527/post/images/2020/jvm_18_0013.png alt=0013></p><ol><li>标记-整理算法(Mark-Compact)</li></ol><p>标记过程和上面一样，清除时令存活对象的一段移动，然后清除指针边界一侧的内存区域。</p><p>这种算法的特点：</p><ul><li>没有内存碎片</li><li>比标记清除算法花更多时间进行compact</li></ul><ol start=3><li><strong>复制算法(Copying)</strong></li></ol><p>将可用内存分成两块，每次只使用其中的一块，当半区内存用完了，就把当前存活的对象复制到另外一块中去，然后将原来的那一块内存整体一次性清除掉。这样每次回收内存都是对整个半区回收，不用考虑内存碎片问题，分配内存时候只需要移动堆的指针，按顺序分配即可，实现简单，运行高效。<strong>缺点是内存变为原来的一半，空间代价太高。</strong></p><p>现代商业虚拟机都是采用复制算法来回收新生代，将新生代划分为eden和2个survivor区，真正只使用eden和其中一块survivor区，另一块survivor区保持空闲，GC时，会将eden和survivor中存货的对象一次性拷贝到空闲的那个survivor中，然后一次性清除eden和原来的survivor区。</p><p>复制算法特点：</p><ul><li>只需要扫描存活的对象，效率更高</li><li>不会产生内存扫描</li><li>需要浪费额外的内存空间作为复制区域</li><li>复制算法适合生命周期非常短的对象，这样每次能回收大部分对象，存活的对象少，相应的复制空间开销就少</li></ul><ol start=4><li><strong>分代算法(Generational)</strong></li></ol><p>商业虚拟机都是采用分代收集算法，根据对象的存活周期将对象划分为新生代和老年代，各个年代根据自己的特点采用合适的收集算法。比如，新生代大量的对象生命周期很短，存活对象少，只需要付出少量对象的复制空间成本即可。对于老年代可以采用标记清除或标记整理算法回收。
<img src=https://cdn.jsdelivr.net/gh/bugfix123/CDN/9527/post/images/2020/jvm_18_gc01.png alt=gc01>
年轻代包括Eden Space，From Space和To Space这三部分，From Space和To Space又叫Survivor，默认情况下他们的大小比例是8：1：1。
<img src=https://cdn.jsdelivr.net/gh/bugfix123/CDN/9527/post/images/2020/jvm_18_gc02.png alt=gc02></p><p>对象一般在Eden Space中生成，当Eden Space满了时，存活的对象被复制到From Space，当Eden Space再次满了，Eden Space中存活的对象和From Space对象中存活的对象一并被复制到To Space，如果To Space对象满了，多余的对象或者存活超龄的对象，就会被复制到老年代。From Space和To Space完全对称，轮流替换。</p><p>大多数对象在Eden Space上分配内存，对于一些大对象，直接在老年代分配内存。</p><h1 id=gc时的引用处理>GC时的引用处理<a href=#gc时的引用处理 class=hanchor arialabel=Anchor>&#8983;</a></h1><p>GC要做的事情是将那些dead对象所占的内存回收。Hotspot认为没有引用的对象是dead的。Hotspot的引用分为4种：</p><ul><li>Strong 通过Object o = new Object()创建的引用</li><li>Soft、Weak和Phantom都是继承自Reference
当Full GC时候，对Reference引用特殊处理：</li><li>Soft：内存不够或长期不用时会被GC</li><li>Weak：一定被GC</li><li>Phantom：本来就没引用，当从JVM 堆中释放内存时会通知</li></ul><h1 id=gc的时机>GC的时机<a href=#gc的时机 class=hanchor arialabel=Anchor>&#8983;</a></h1><p>在分代收集的基础上，GC分为Minor GC和Full GC。</p><ul><li><strong>Minor GC</strong></li></ul><p>触发条件：新对象生成时，Eden 满了
特点：大多数对象在Minor GC时回收，效率高，执行的时间比较短</p><ul><li><strong>Full GC</strong></li></ul><p>对整个JVM进行整理，包括Young，Old和Metaspace。</p><p>触发时机：a. Old满了 b. Metaspace满了 c. 调用System.gc()</p><p>效率低，尽量少执行。一旦出现Full GC，就会出现<strong>Stop The World</strong>，业务线程暂停执行。</p><h1 id=垃圾回收器>垃圾回收器<a href=#垃圾回收器 class=hanchor arialabel=Anchor>&#8983;</a></h1><p>分代模型是GC的宏观愿景，而垃圾回收器是GC算法的具体实现。Hotspot提供了多种垃圾回收器，应当根据具体的业务场景采用不同的垃圾回收器，没有一种垃圾回收器是万能的。</p><p>GC时并行和并发的概念：</p><ul><li>并行(Parallel)：多个GC线程同时工作，而用户线程处于等待状态。</li><li>并发(Concurrent)：垃圾回收的同时，运行用户线程工作。</li></ul><p><strong>单线程收集器(Serial)</strong>：收集时会暂停所有的工作线程，使用复制算法它是JVM在Client模式下的默认新生代垃圾回收器。主要特点：</p><ul><li>最早的收集器，单线程</li><li>新生代和老年代都可以使用</li><li>复制算法 + 标记整理算法</li></ul><p><strong>ParNew收集器</strong>：Serial收集器的多线程版本，算法、STW等都和Serial一样，它是JVM在Server模式下默认的新生代垃圾回收器。</p><p><strong>Parallel Scavenge收集器</strong>：多线程收集器，复制算法，它主要特点是吞吐量高，也就是GC的总运行时间短。STW不理想。</p><p><strong>Serial Old</strong>：单线程版本收集器，老年代版本。</p><p><strong>Parallel Old</strong>：Parallel Scavenge的老年代实现，多线程的标记清除算法，吞吐量好。Parallel Scavenge + Parallel Old=高吞吐量，但是STW不理想。</p><p><strong>CMS(Concurrent Mark Sweep)</strong>：很复杂的老年代收集器，主要特点：追求最短停顿时间，并发（GC和用户线程同时进行），标记清除算法，一般结合ParNew收集器。它通过占用很多CPU资源来减少用户线程停顿。</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://dongzhi.me/2020/07/09/jvm-learn-17/><span class=button__icon>←</span>
<span class=button__text>JVM Learn 17 JVM内存排查相关命令用法</span></a></span>
<span class="button next"><a href=https://dongzhi.me/2020/07/09/jvm-learn-19/><span class=button__text>JVM Learn 19 JVM垃圾回收算法总结</span>
<span class=button__icon>→</span></a></span></div></div><h3 style=margin-inline-start:1em;margin-bottom:auto>评论</h3><aside id=comments><div id=hyvor-talk-view></div><script type=text/javascript>var HYVOR_TALK_WEBSITE=1505;var HYVOR_TALK_CONFIG={url:false,id:false};</script><script async type=text/javascript src=https://talk.hyvor.com/web-api/embed></script></aside></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2020 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span style=margin-right:10px>:: Theme made by <a href=https://twitter.com/panr>panr</a></span>
<span id=busuanzi_container_site_uv>:: 您是本站第<span id=busuanzi_value_site_uv></span>位访客</span></div></div></footer><script src=https://dongzhi.me/assets/main.js></script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script src=https://cdn.jsdelivr.net/gh/bugfix123/CDN@master/modules/plyr/3.6.2/plyr.polyfilled.min.js></script><script>const players=Plyr.setup('.js-player',{iconUrl:'/modules/plyr/3.6.2/plyr.svg'});</script></div></body></html>