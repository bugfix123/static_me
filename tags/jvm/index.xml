<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>jvm on 志哥笔记</title>
    <link>https://dongzhi.me/tags/jvm/</link>
    <description>Recent content in jvm on 志哥笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 17 Sep 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://dongzhi.me/tags/jvm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>深入浅出理解Java垃圾收集过程</title>
      <link>https://dongzhi.me/2020/09/17/understanding-the-java-memory-model-and-the-garbage-collector/</link>
      <pubDate>Thu, 17 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dongzhi.me/2020/09/17/understanding-the-java-memory-model-and-the-garbage-collector/</guid>
      <description>&lt;p&gt;在这篇文章中我们将尝试搞清楚Java内存模型以及垃圾收集器是如何工作的。在这篇文章中我使用的是JDK8 Oracle Hot Spot 64 bit版本的JVM。首先我描述一下Java进程使用的不同内存区域。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>记一次公司JVM堆溢出抽丝剥茧定位的过程</title>
      <link>https://dongzhi.me/2020/08/27/a_example_of_jvm_problem_solve_in_product_environment/</link>
      <pubDate>Thu, 27 Aug 2020 20:09:50 +0800</pubDate>
      
      <guid>https://dongzhi.me/2020/08/27/a_example_of_jvm_problem_solve_in_product_environment/</guid>
      <description>背景 公司线上有个tomcat服务，里面合并部署了大概8个微服务，之所以没有像其他微服务那样单独部署，其目的是为了节约服务器资源，况且这8个服务是属于边缘服务，并发不高，就算宕机也不会影响核心业务。 因为</description>
    </item>
    
    <item>
      <title>JVM Learn 08 线程上下文类加载器和Service Loader</title>
      <link>https://dongzhi.me/2020/07/07/jvm-learn-08/</link>
      <pubDate>Tue, 07 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dongzhi.me/2020/07/07/jvm-learn-08/</guid>
      <description>双亲委托机制的局限性 当一个类由类加载器A加载，那么这个类的依赖类也由相同的类加载器加载器，在双亲委托模型下，类的加载是自上而下的，即下层的类加载器会委托上层加载。对于SPI来说，很多接口是由JAVA核</description>
    </item>
    
    <item>
      <title>JVM Learn 09 类的字节码结构</title>
      <link>https://dongzhi.me/2020/07/07/jvm-learn-09/</link>
      <pubDate>Tue, 07 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dongzhi.me/2020/07/07/jvm-learn-09/</guid>
      <description>概念 字节码文件(.class)由JVM规范规定，主要包括魔数、JDK版本号(小版本和大版本)、常量池、类的访问标志、类的接口和父类信息、成员变量信息，方法信息等。 对于java中的数据类型，字节码中的对</description>
    </item>
    
    <item>
      <title>JVM Learn 10 类的虚方法机制</title>
      <link>https://dongzhi.me/2020/07/07/jvm-learn-10/</link>
      <pubDate>Tue, 07 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dongzhi.me/2020/07/07/jvm-learn-10/</guid>
      <description>基本概念总结 符号引用在类的加载阶段或者第一次引用时转换成直接引用，这叫做静态解析。一些符号引用则在每次运行时转换成直接引用，这种转换是动态链接，java的多态正是在此时实现的。 方法调用的几个指令： in</description>
    </item>
    
    <item>
      <title>JVM Learn 11 关于栈的指令操作的例子</title>
      <link>https://dongzhi.me/2020/07/07/jvm-learn-11/</link>
      <pubDate>Tue, 07 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dongzhi.me/2020/07/07/jvm-learn-11/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本例以一个简单的加减乘除的例子，来熟悉虚拟机的操作数栈的工作流程。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>JVM Learn 12 从字节码看动态代理</title>
      <link>https://dongzhi.me/2020/07/07/jvm-learn-12/</link>
      <pubDate>Tue, 07 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dongzhi.me/2020/07/07/jvm-learn-12/</guid>
      <description>&lt;p&gt;动态代理是在运行时，通过反射机制实现动态代理，并且能够代理各种类型的对象。相对于静态代理，它的优势是不需要事先知道被代理的类型，可以与被代理的类解耦，同时可以大大减少代理类的数量。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>JVM Learn 13 JVM的内存划分</title>
      <link>https://dongzhi.me/2020/07/07/jvm-learn-13/</link>
      <pubDate>Tue, 07 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dongzhi.me/2020/07/07/jvm-learn-13/</guid>
      <description>内存划分 java虚拟机的内存划分主要包括以下几个部分： 程序计数器：记录当前线程执行的下一条指令的地址，很小的空间 虚拟机栈(stack): 每个方法执行时候在栈里面创建一个栈帧，用于存储局部变量表，操作数</description>
    </item>
    
    <item>
      <title>JVM Learn 14 java堆的转储与Jvisualvm</title>
      <link>https://dongzhi.me/2020/07/07/jvm-learn-14/</link>
      <pubDate>Tue, 07 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dongzhi.me/2020/07/07/jvm-learn-14/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文记录一下java队的转储和JVisualVM的用法。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>JVM Learn 15 java栈的测试</title>
      <link>https://dongzhi.me/2020/07/07/jvm-learn-15/</link>
      <pubDate>Tue, 07 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dongzhi.me/2020/07/07/jvm-learn-15/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;java的虚拟机栈中可能会存在java.lang.StackOverflowError这个错误，本例中通过方法的递归来模拟出该异常，进而研究其细节。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>JVM Learn 01.类的加载之初体验</title>
      <link>https://dongzhi.me/2020/07/06/jvm-learn-01/</link>
      <pubDate>Mon, 06 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dongzhi.me/2020/07/06/jvm-learn-01/</guid>
      <description>在java中，类型（可以理解成class）的加载、连接和初始化都是在程序运行期间完成的。在运行期完成可以为程序开发人员提供了更大的灵活性。 加载：将已经存在的class文件加载到内存,查找并加载类的二进</description>
    </item>
    
    <item>
      <title>JVM Learn 02 常量的那点东西</title>
      <link>https://dongzhi.me/2020/07/06/jvm-learn-02/</link>
      <pubDate>Mon, 06 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dongzhi.me/2020/07/06/jvm-learn-02/</guid>
      <description>常量在编译阶段会存入调用这个常量的方法所在类的常量池中，本质上调用类并没有直接引用定义常量的类，因此并不会出发定义常量类的初始化。如果该常量值时动态生成的，则不会放在常量池中，会导致定义常量的类主动使</description>
    </item>
    
    <item>
      <title>JVM Learn 03 理解类的初始化的一个简单例子</title>
      <link>https://dongzhi.me/2020/07/06/jvm-learn-03/</link>
      <pubDate>Mon, 06 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dongzhi.me/2020/07/06/jvm-learn-03/</guid>
      <description>这是一个经典例子，很多面试题中出现过。首先引入正常的情况： 1package com.test.jvm.learn01; 2 3public class Main2 { 4 public static void main(String[] args) { 5 System.out.println(Counter.counter1); 6 System.out.println(Counter.counter2); 7 } 8} 9 10 11package com.test.jvm.learn01; 12 13public class Counter { 14 15 public static int counter1; 16 public static int counter2 = 0; 17 public static Counter counter = new Counter(); 18 19 private Counter() { 20 counter1++; 21 counter2++; 22 System.out.println(counter1); 23 System.out.println(counter2); 24 } 25 26 public static Counter</description>
    </item>
    
    <item>
      <title>JVM Learn 04 类加载器(一)</title>
      <link>https://dongzhi.me/2020/07/06/jvm-learn-04/</link>
      <pubDate>Mon, 06 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dongzhi.me/2020/07/06/jvm-learn-04/</guid>
      <description>基本概念 java的类加载器(class loader)，用来将java的字节码文件(.class)读取到内存中，生成一个Java.lang.Class对象。通过Class类的newInstance()方</description>
    </item>
    
    <item>
      <title>JVM Learn 05 类加载器(二)</title>
      <link>https://dongzhi.me/2020/07/06/jvm-learn-05/</link>
      <pubDate>Mon, 06 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dongzhi.me/2020/07/06/jvm-learn-05/</guid>
      <description>父子类加载器的命名空间 类A中引用了类B，那么加载类B时，由类A的类加载器按照双亲委托机制尝试加载。子类加载器加载的类可以引用父类加载器加载的类，而父类加载器加载的类不能引用子类加载器加载的类。 测试案例</description>
    </item>
    
    <item>
      <title>JVM Learn 06 类加载器(三)</title>
      <link>https://dongzhi.me/2020/07/06/jvm-learn-06/</link>
      <pubDate>Mon, 06 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dongzhi.me/2020/07/06/jvm-learn-06/</guid>
      <description>继续前面两篇类加载器的内容，本篇补充总结类加载的一些关键问题。 Java的类加载器本身如何被加载？ Java的根类加载器(Bootstrap Class Loader)，由C++编写，它是内建在JVM方法区内的一块字</description>
    </item>
    
    <item>
      <title>JVM Learn 07 Launcher源码解析</title>
      <link>https://dongzhi.me/2020/07/06/jvm-learn-07/</link>
      <pubDate>Mon, 06 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dongzhi.me/2020/07/06/jvm-learn-07/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;这次重新阅读了一下sun.misc.Launcher这个类的源码，这里总结一下。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
  </channel>
</rss>